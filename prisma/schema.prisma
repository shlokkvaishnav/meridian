generator client {
  provider = "prisma-client"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== Multi-tenant & Auth Models ====================
// NOTE: These models introduce a proper multi-tenant, user-based architecture.
// Existing single-session `AppSettings` remains for backward compatibility and migration.

model User {
  id            String   @id @default(cuid())
  name          String?
  email         String?  @unique
  emailVerified DateTime?
  image         String?

  // GitHub identity (for convenience)
  githubId    Int?    @unique
  githubLogin String? @unique

  // Auth.js relations
  accounts Account[]
  sessions Session[]

  // Multi-tenant relations
  memberships       Membership[]
  githubConnections GitHubConnection[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Tenant {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique

  billingPlan   String?
  billingStatus String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships       Membership[]
  repositories      Repository[]
  pullRequests      PullRequest[]
  reviews           Review[]
  comments          Comment[]
  syncJobs          SyncJob[]
  insights          Insight[]
  metricSnapshots   MetricSnapshot[]
  githubConnections GitHubConnection[]
  teams             Team[]
}

model Membership {
  id        String     @id @default(cuid())
  userId    String
  tenantId  String
  role      TenantRole @default(MEMBER)
  createdAt DateTime   @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([tenantId])
}

enum TenantRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

model GitHubConnection {
  id             String         @id @default(cuid())
  tenantId       String
  userId         String?
  provider       GitHubProvider @default(GITHUB_OAUTH)
  installationId Int?

  // Encrypted GitHub OAuth access token (AES-256-GCM)
  encryptedToken String
  tokenCreatedAt DateTime @default(now())
  tokenExpiresAt DateTime?
  scopes         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([userId])
}

enum GitHubProvider {
  GITHUB_OAUTH
  GITHUB_APP
}

// ==================== App Settings ====================

model AppSettings {
  id String @id @default(cuid())

  // Session ID to identify the browser session
  sessionId String @unique

  // Encrypted GitHub Personal Access Token
  encryptedToken String
  tokenCreatedAt DateTime @default(now())

  // GitHub user info
  githubLogin  String?
  githubUserId Int?
  email        String?
  name         String?
  avatarUrl    String?

  lastSyncedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  repositories Repository[]
  insights     Insight[]
  syncJobs     SyncJob[]

  @@index([githubLogin])
  @@index([sessionId])
}

// ==================== Repositories ====================

model Repository {
  id           String @id @default(cuid())

  // Multi-tenant owner (optional during migration; make required once all data is migrated)
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  githubRepoId Int // Removed @unique because multiple users might track the same repo? 
  // Actually, for now let's keep it simple. If User A and User B both track "facebook/react", 
  // we probably want separate rows so they have their own sync state.
  // So yes, remove @unique from githubRepoId, or scope it to ownerId.

  name          String
  fullName      String // e.g., "username/repo-name"
  defaultBranch String  @default("main")
  description   String?

  isPrivate    Boolean   @default(false)
  isActive     Boolean   @default(true)
  lastSyncedAt DateTime?

  // Owner (User Session)
  ownerId String
  owner   AppSettings @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pullRequests    PullRequest[]
  metricSnapshots MetricSnapshot[]

  @@unique([ownerId, githubRepoId]) // Ensure a user can't add the same repo twice
  @@index([tenantId])
  @@index([fullName])
  @@index([lastSyncedAt])
  @@index([isActive])
  @@index([ownerId])
}

// ==================== Pull Requests ====================

model PullRequest {
  id         String  @id @default(cuid())

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  githubPrId Int
  number     Int
  title      String
  body       String? @db.Text
  state      PRState

  repositoryId String
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  // Author as simple string (GitHub login)
  authorLogin     String
  authorAvatarUrl String?

  createdAt DateTime
  updatedAt DateTime
  closedAt  DateTime?
  mergedAt  DateTime?

  // Computed metrics (denormalized for query performance)
  linesAdded   Int @default(0)
  linesDeleted Int @default(0)
  filesChanged Int @default(0)
  commitsCount Int @default(0)

  timeToFirstReview Int? // minutes
  timeToMerge       Int? // minutes
  reviewCycleCount  Int  @default(0)

  reviews  Review[]
  comments Comment[]

  @@index([tenantId])
  @@unique([repositoryId, number])
  @@index([repositoryId])
  @@index([repositoryId, createdAt])
  @@index([repositoryId, mergedAt])
  @@index([repositoryId, updatedAt])
  @@index([state])
  @@index([mergedAt])
  @@index([updatedAt])
}

enum PRState {
  OPEN
  CLOSED
  MERGED
}

model Review {
  id             String @id @default(cuid())
  githubReviewId Int    @unique

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  pullRequestId String
  pullRequest   PullRequest @relation(fields: [pullRequestId], references: [id], onDelete: Cascade)

  // Reviewer as simple string (GitHub login)
  reviewerLogin     String
  reviewerAvatarUrl String?

  state       ReviewState
  body        String?     @db.Text
  submittedAt DateTime

  createdAt DateTime @default(now())

  @@index([tenantId])
  @@index([pullRequestId])
  @@index([reviewerLogin])
  @@index([submittedAt])
}

enum ReviewState {
  APPROVED
  CHANGES_REQUESTED
  COMMENTED
  DISMISSED
}

model Comment {
  id              String @id @default(cuid())
  githubCommentId Int    @unique

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  pullRequestId String
  pullRequest   PullRequest @relation(fields: [pullRequestId], references: [id], onDelete: Cascade)

  // Author as simple string (GitHub login)
  authorLogin     String
  authorAvatarUrl String?

  body      String   @db.Text
  createdAt DateTime
  updatedAt DateTime

  @@index([tenantId])
  @@index([pullRequestId])
  @@index([authorLogin])
}

// ==================== Sync Jobs ====================

model SyncJob {
  id String @id @default(cuid())

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  jobType String // 'full_sync', 'repo_sync', 'pr_sync'
  status  JobStatus @default(PENDING)

  // Optional: which repo is being synced
  repositoryId String?

  ownerId String?
  owner   AppSettings? @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  progress Json    @default("{}")
  error    String? @db.Text

  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// ==================== AI Insights ====================

model Insight {
  id String @id @default(cuid())

  title       String
  description String          @db.Text
  type        InsightType
  category    InsightCategory
  priority    Int // 1-10

  // Additional data (JSON for flexibility)
  data Json @default("{}")

  generatedAt DateTime @default(now())
  isRead      Boolean  @default(false)
  isDismissed Boolean  @default(false)

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Owner (User Session)
  ownerId String
  owner   AppSettings @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([generatedAt])
  @@index([priority])
  @@index([tenantId])
  @@index([ownerId])
}

enum InsightType {
  WARNING
  CAUTION
  INFO
  SUCCESS
}

enum InsightCategory {
  BOTTLENECK
  WORKLOAD
  VELOCITY
  COLLABORATION
  QUALITY
}

// ==================== Historical Snapshots ====================

model MetricSnapshot {
  id   String   @id @default(cuid())
  date DateTime @db.Date // Normalized to YYYY-MM-DD

  // Multi-tenant owner
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  repositoryId String
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  // Cycle Time Stats
  cycleTimeP50 Int? // minutes
  cycleTimeP95 Int? // minutes

  // Velocity
  mergeRate Float? // 0-1
  prsOpened Int    @default(0)
  prsMerged Int    @default(0)

  createdAt DateTime @default(now())

  @@index([tenantId])
  @@unique([repositoryId, date])
  @@index([date])
}

// ==================== Teams (per-tenant contributor grouping) ====================

model Team {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members TeamMember[]

  @@index([tenantId])
}

model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  login     String
  avatarUrl String?
  createdAt DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, login])
  @@index([teamId])
}

